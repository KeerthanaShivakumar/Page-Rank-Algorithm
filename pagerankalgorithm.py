# -*- coding: utf-8 -*-
"""PageRankAlgorithm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gsEukUq5Lt0LxALmSbYKGYz2Jif9xXT6

#Keerthana Shivakumar

#PES1UG20CS204

#LA Assignment 5 - Applications of Linear algebra for Page Rank Algorithm.

#Page Rank algorithm
It is a way to measure the importance of websites. Using the random walk method, we pick one node in random and choose its neighbours uniformly at random and continue until convergence is reached. After N iterations, a point will come until which there will be no more change in points of every node (convergence)

Steps to apply Random Walk Method:


*   Create a directed graph with N nodes
*   Perform random walk
*   Sort nodes as per walks during random walk
*   Compare with the inbuilt Page Rank method
"""

#Import necessary libraries for implementation
import networkx as nx
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import operator
import random as rd

"""Generate a directed graph with 25 nodes using networkx library. Set the probability of having edge between 2 nodes in a graph as 0.6."""

# created a directed graph
graph=nx.gnp_random_graph(25,0.6,directed=True)
#draw a graph
nx.draw(graph,with_labels=True,font_color='red',font_size=10,node_color='yellow')
#plot a graph
plt.show()

#number of nodes for graph
count=graph.number_of_nodes()
count

"""Neighbours of the node are those nodes that the given node points to."""

#graph neighbours of a node 1
print(list(graph.neighbors(3)))

"""Perform Random Walk Method by generating a random walk score for each and every node by starting with a random node and doing a walk through its neighbour nodes and increasing score. Consider 600000 iterations for this process."""

#Page Rank Algorithm-Calculating random walk score
rank_dict={}
x=rd.randint(0,25) #Pick a random node
for j in range(0,25):
  rank_dict[j]=0 #Initialize all scores to zero
rank_dict[x]=rank_dict[x]+1 #Increase scores by one after passing through the neighoburs
for i in range(600000): #repeat the iteration by 600000 times
  list_n=list(graph.neighbors(x))
  if(len(list_n)==0):
    x=rd.randint(0,25)
    rank_dict[x]=rank_dict[x]+1
  else:
    x=rd.choice(list_n)
    rank_dict[x]=rank_dict[x]+1
print("Random Walk Score Updated")

"""Normalize the scores stored in the dictionary by dividing the random walk score by the number of iterations."""

#normalising values
for j in range(0,25):
  rank_dict[j]=rank_dict[j]/600000

"""Obtain the random scores of the graph using the built-in function pagerank in networkx library and sort the obtained dictionary based on the scores."""

#Page rank by networkx library
pagerank=nx.pagerank(graph)
#sorting both dictionaries based on items
pagerank_sorted=sorted(pagerank.items(),key=lambda v:(v[1],v[0]),reverse=True)
pagerank_sorted

"""Sort the dictionary generated by the algorithm and store it."""

#sorting the rank_dict based on values
rank_dict_sorted=sorted(rank_dict.items(),key=lambda v:(v[1],v[0]),reverse=True)
rank_dict_sorted

"""Compare both the results."""

print("The order generated by our implementation algorithm is\n")
for i in rank_dict_sorted:
  print(i[0],end=" ")
print("\n\nThe order generated by networkx library is\n")
for i in pagerank_sorted:
  print(i[0],end=" ")

"""#Algorithm generated by the implementation algorithm is almost the same as the order generated by networkx library."""